
//This file should be called F_position.c
//This is autogenerated code. Edit by hand at your peril!
#include "F_position.h"

void position_init_all_vars(enforcervars_position_t* me, inputs_position_t* inputs, outputs_position_t* outputs) {
	//set any input vars with default values
	
	//set any output vars with default values
	

	
	me->_policy_safe_state = POLICY_STATE_position_safe_rabbit;
	//input policy internal vars
	
	me->turn_timer = 0;
	
	me->boundry = 9;
	
	
}

void position_run_via_enforcer(enforcervars_position_t* me, inputs_position_t* inputs, outputs_position_t* outputs) {
	//run the policies in reverse order for the inputs (last policies have highest priority)
	
	 position_run_input_enforcer_safe(me, inputs);
	

	position_run(inputs, outputs);

	//run policies in specified order for outputs
	position_run_output_enforcer_safe(me, inputs,outputs);
	
}


//input policies

//INPUT POLICY safe BEGIN
//This will run the input enforcer for position's policy safe
void position_run_input_enforcer_safe(enforcervars_position_t* me, inputs_position_t* inputs) {
	switch(me->_policy_safe_state) {
		case POLICY_STATE_position_safe_rabbit:
			
			if(inputs->ry == inputs->w1y) {
				//transition rabbit -> violation on ry = w1y
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				
			} 
			if(inputs->rx == inputs->w1x) {
				//transition rabbit -> violation on rx = w1x
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				
			} 
			if(inputs->ry == inputs->w2y) {
				//transition rabbit -> violation on ry = w2y
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				
			} 
			if(inputs->rx == inputs->w2x) {
				//transition rabbit -> violation on rx = w2x
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				
			} 
			
			break;

		case POLICY_STATE_position_safe_wolves:
			
			if(me->turn_timer == 1 && inputs->w1y == inputs->w2y) {
				//transition wolves -> violation on turn_timer = 1 and w1y = w2y
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				
			} 
			if(me->turn_timer == 1 && inputs->w1x == inputs->w2x) {
				//transition wolves -> violation on turn_timer = 1 and w1x = w2x
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				
			} 
			if(me->turn_timer == 2 && inputs->w2y == inputs->w1y) {
				//transition wolves -> violation on turn_timer = 2 and w2y = w1y
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				
			} 
			if(me->turn_timer == 2 && inputs->w2x == inputs->w1x) {
				//transition wolves -> violation on turn_timer = 2 and w2x = w1x
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				
			} 
			
			break;

		
	}
}

//INPUT POLICY safe END



//output policies

//OUTPUT POLICY safe BEGIN
//This will run the input enforcer for position's policy safe
void position_run_output_enforcer_safe(enforcervars_position_t* me, inputs_position_t* inputs, outputs_position_t* outputs) {
	//advance timers
	
	me->turn_timer++;
	
	//run enforcer
	switch(me->_policy_safe_state) {
		case POLICY_STATE_position_safe_rabbit:
			
			if(outputs->new_rx <= 0) {
				//transition rabbit -> violation on new_rx <= 0
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_rx = inputs->rx;
				
			} 
			if(outputs->new_rx >= me->boundry) {
				//transition rabbit -> violation on new_rx >= boundry
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_rx = inputs->rx;
				
			} 
			if(outputs->new_ry <= 0) {
				//transition rabbit -> violation on new_ry <= 0
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_ry = inputs->ry;
				
			} 
			if(outputs->new_ry >= me->boundry) {
				//transition rabbit -> violation on new_ry >= boundry
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_ry = inputs->ry;
				
			} 
			if(outputs->new_rx == inputs->w1x && inputs->ry == inputs->w1y) {
				//transition rabbit -> violation on new_rx = w1x and ry = w1y
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_rx = inputs->rx;
				
			} 
			if(outputs->new_ry == inputs->w1y && inputs->rx == inputs->w1x) {
				//transition rabbit -> violation on new_ry = w1y and rx = w1x
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_ry = inputs->ry;
				
			} 
			if(outputs->new_rx == inputs->w2x && inputs->ry == inputs->w2y) {
				//transition rabbit -> violation on new_rx = w2x and ry = w2y
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_rx = inputs->rx;
				
			} 
			if(outputs->new_ry == inputs->w2y && inputs->rx == inputs->w2x) {
				//transition rabbit -> violation on new_ry = w2y and rx = w2x
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_ry = inputs->ry;
				
			} 

			break;

		case POLICY_STATE_position_safe_wolves:
			
			if(outputs->new_w1x < 0) {
				//transition wolves -> violation on new_w1x < 0
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_w1x = inputs->w1x;
				
			} 
			if(outputs->new_w1x > me->boundry) {
				//transition wolves -> violation on new_w1x > boundry
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_w1x = inputs->w1x;
				
			} 
			if(outputs->new_w1y < 0) {
				//transition wolves -> violation on new_w1y < 0
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_w1y = inputs->w1y;
				
			} 
			if(outputs->new_w1y > me->boundry) {
				//transition wolves -> violation on new_w1y > boundry
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_w1y = inputs->w1y;
				
			} 
			if(me->turn_timer == 1 && outputs->new_w1x == inputs->w2x && inputs->w1y == inputs->w2y) {
				//transition wolves -> violation on turn_timer = 1 and new_w1x = w2x and w1y = w2y
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_w1x = inputs->w1x;
				
			} 
			if(me->turn_timer == 1 && outputs->new_w1y == inputs->w2y && inputs->w1x == inputs->w2x) {
				//transition wolves -> violation on turn_timer = 1 and new_w1y = w2y and w1x = w2x
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_w1y = inputs->w1y;
				
			} 
			if(outputs->new_w2x <= 0) {
				//transition wolves -> violation on new_w2x <= 0
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_w2x = inputs->w2x;
				
			} 
			if(outputs->new_w2x >= me->boundry) {
				//transition wolves -> violation on new_w2x >= boundry
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_w2x = inputs->w2x;
				
			} 
			if(outputs->new_w2y <= 0) {
				//transition wolves -> violation on new_w2y <= 0
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_w2y = inputs->w2y;
				
			} 
			if(outputs->new_w2y >= me->boundry) {
				//transition wolves -> violation on new_w2y >= boundry
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_w2y = inputs->w2y;
				
			} 
			if(me->turn_timer == 2 && outputs->new_w2x == inputs->w1x && inputs->w2y == inputs->w1y) {
				//transition wolves -> violation on turn_timer = 2 and new_w2x = w1x and w2y = w1y
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_w2x = inputs->w2x;
				
			} 
			if(me->turn_timer == 2 && outputs->new_w2y == inputs->w1y && inputs->w2x == inputs->w1x) {
				//transition wolves -> violation on turn_timer = 2 and new_w2y = w1y and w2x = w1x
				//select a transition to solve the problem
				
				//Recovery instructions manually provided.
				outputs->new_w2y = inputs->w2y;
				
			} 

			break;

		
	}

	//select transition to advance state
	switch(me->_policy_safe_state) {
		case POLICY_STATE_position_safe_rabbit:
			
			if(me->turn_timer == 1) {
				//transition rabbit -> wolves on turn_timer = 1
				me->_policy_safe_state = POLICY_STATE_position_safe_wolves;
				//set expressions
				
				me->turn_timer = 0;
			} 
			
			break;

		case POLICY_STATE_position_safe_wolves:
			
			if(me->turn_timer == 2) {
				//transition wolves -> rabbit on turn_timer = 2
				me->_policy_safe_state = POLICY_STATE_position_safe_rabbit;
				//set expressions
				
				me->turn_timer = 0;
			} 
			
			break;

		
	}
}

//OUTPUT POLICY safe END



